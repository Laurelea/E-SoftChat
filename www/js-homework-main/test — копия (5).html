<html>
<head>
    <script>
    class Validator {
        constructor() {
            this._errors = [];
        }

        get Errors() {
            return this._errors;
        }
        /**
         *
         * @param schema
         * @param dataToValidate
         * @returns {boolean}
         */
        numberFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minimum" :
                        document.write("Minimum!<br>");
                        if (dataToValidate < schema["minimum"]) this.Errors.push('Value is less than it can be');
                        break
                    case "maximum" :
                        document.write("Maximum!<br>");
                        if (dataToValidate > schema["maximum"]) this.Errors.push('Value is greater than it can be');
                        break
                    case "enum" :
                        document.write("Enum!<br>");
                        document.write("Enum list: " + schema["enum"]+ '<br>');
                        document.write("Data to validate:" + dataToValidate + '<br>');
                        document.write("Is included: "+ schema["enum"].includes(dataToValidate)+"<br>");
                        if (!(schema["enum"].includes(dataToValidate))) this.Errors.push('The enum does not support value');
                        break
                }
            }
            console.log(this._errors);
            return (this._errors.length == 0) ? true : false;
        }
        stringFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minLength" :
                        document.write("MinLength!<br>");
                        if (dataToValidate.length < schema["minLength"]) this.Errors.push('Too short string');
                        break
                    case "maxLength" :
                        document.write("Maxlength!<br>");
                        if (dataToValidate.length > schema["maxlength"]) this.Errors.push('Too long string');
                        break
                    case "pattern" :
                        document.write("Regular!<br>");
                        if (dataToValidate.match(schema["pattern"]) == null) this.Errors.push('String does not match pattern');
                        break
                    case "enum" :
                        if (!(schema["enum"].includes(dataToValidate))) this.Errors.push('The enum does not support value');
                        break
                    case "format" :
                        if (((schema["format"] == "email") && (dataToValidate.match(/^[^\s@]+@[^\s@]+$/) == null)) ||
                            ((schema["format"] == "date") && (dataToValidate.match(/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/) == null))) {
                            this.Errors.push('Format of string is not valid');
                        }
                        break
                }
                }
            return (this.Errors.length == 0) ? true : false;

        }
        objectFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minProperties" :
                        document.write("MinProperties!<br>");
                        console.log("Object.keys(dataToValidate).length " + Object.keys(dataToValidate).length)
                        console.log("schema[\"minproperties\"] " + schema["minProperties"])
                        if (Object.keys(dataToValidate).length < schema["minProperties"]) this.Errors.push('Too few properties in object');
                        break
                    case "maxProperties" :
                        document.write("Maxproperties!<br>");
                        if (Object.keys(dataToValidate).length > schema["maxProperties"]) this.Errors.push('Too many properties in object');
                        break
                    case "required" :
                        // document.write("Required!<br>");
                        const setDatatoval = Object.keys(dataToValidate);
                        document.write("Keys of Data to validate: " +setDatatoval+ "<br>");
                        // document.write("Keys of schema: " +schema["required"]+ "<br>");
                        // const myIntersection = setDatatoval.filter(x => schema["required"].includes(x))
                        // console.log("Intersection: " + myIntersection);
                        // console.log("If equal :" +  myIntersection == schema["required"]);
                        // // var b = Object.keys(dataToValidate).filter(x => schema["required"].includes(x)) == schema["required"];
                        // if (Array.from(Object.keys(dataToValidate)).includes(schema["required"]) == false) this.Errors.push('Property required, but value is undefined');
                        // break
                        for (var i in schema["required"]) {
                            document.write("Curr elem: " + i + "<br>")
                            if (!(Object.keys(dataToValidate).includes(schema["required"][i]))) this.Errors.push('Property required, but value is undefined');
                        }
                        break
                    case "properties" :
                        document.write("Properties!!<br>");
                        for (var elem in schema["properties"]) {

                            //Это чисто для проверки:
                            document.write("Current elem is: " + elem +"<br>")
                            document.write("What to put in new Validator: "+ "<br>");
                            document.write("Instead of schema: schema[\"properties\"].elem"+ ' ' +schema["properties"][elem]+"<br>");
                            document.write("<br>" + "Current schema: " + "<br>");
                            for (var key in schema["properties"][elem]) { //обращаемся к индексам
                                document.write(key, ' ', schema["properties"][elem][key], '<br>')
                            }
                            document.write("<br>")
                            document.write("Instead of data: dataToValidate[elem]"+ ' ' + dataToValidate[elem]+"<br>");
                            console.log(dataToValidate[elem]);

                            //А вот пошёл сам код:
                            const propValidator = new Validator();
                            //дописать после arrays:
                            const addIsValid = propValidator.isValid(schema["properties"][elem], dataToValidate[elem]);
                            document.write("Prop check result: " + addIsValid + "<br><br>");
                        }
                            break
                    case "additionalProperties" :
                        document.write("Add prop!<br>");
                        if (schema["additionalProperties"] == false) {
                            const poolKeys = Object.keys(schema["properties"]);
                            const dataKeys = Object.keys(dataToValidate);
                            const diff = dataKeys.filter(x => !poolKeys.includes(x));
                            console.log(diff);
                            if (diff.length > 0) this.Errors.push('An object cant have additional properties');
                        }
                        break
                }
            }
            console.log("Finished Object Func")
            console.log(this._errors)
            return (this.Errors.length == 0) ? true : false;

        }
        arrayFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minItems" :
                        document.write("MinItems!<br>");
                        if (dataToValidate.length < schema["minItems"]) this.Errors.push('Items count less than can be');
                        break
                    case "maxItems" :
                        document.write("MaxItesm!<br>");
                        if (dataToValidate.length > schema["maxItems"]) this.Errors.push('Items count more than can be');
                        break
                    case "items" :
                        document.write("Items!<br>");
                        if (Object.keys(schema['items']).length > 1) {
                            const posItemTypes = []
                            for (var elem in schema["items"]) {
                                document.write("Element: " + elem + "<br>");
                                document.write("Contents: " + schema["items"].elem + "<br>");
                                posItemTypes.push(schema["items"][elem]["type"]);
                                console.log("Type: " + posItemTypes);
                            }
                            for (var elem in dataToValidate) {
                                if (!(posItemTypes.includes(typeof dataToValidate[elem]))) this.Errors.push('Type is incorrect');
                            }
                        } else {
                            for (var elem in dataToValidate) {
                                if ((typeof dataToValidate[elem]) != schema["items"]["type"]) this.Errors.push('Type is incorrect');
                            }
                        }
                        break
                    case "enum" :
                        document.write("Enum!<br>");
                        // console.log(dataToValidate, typeof dataToValidate);
                        // console.log(schema["enum"], typeof schema["enum"]);
                        if (!(schema["enum"].includes(dataToValidate))) this.Errors.push('The enum does not support one of array elements');
                        // for (var i in dataToValidate) {
                        //     console.log("Curr elem: " + i + ' ' + dataToValidate[i]);
                        //     console.log((schema["enum"].includes(dataToValidate[i])));
                        //     if (!(schema["enum"].includes(dataToValidate[i]))) this.Errors.push('The enum does not support one of array elements')
                        // }
                        break
                    case "contains" :
                        if (!(dataToValidate.includes(schema["contains"]))) this.Errors.push('Must contain a value, but does not');
                        break
                    case "uniqueItems" :
                        document.write("Case Unique!" + "<br>");
                        const tryJSON = dataToValidate.map((object) => JSON.stringify(object));
                        const uSet = new Set(tryJSON);
                        const uniqueElems = Array.from(uSet);
                        const uObjByCont = uniqueElems.map((string) => JSON.parse(string));

                        console.log("uniqueElems: " + uniqueElems);
                        document.write("Length: " + uniqueElems.length + "<br>");
                        if (uniqueElems.length< dataToValidate.length) this.Errors.push('Elements of array not unique');
                        break
                }

            }
            return (this.Errors.length == 0) ? true : false;

        }
        isValid(schema = {}, dataToValidate) {
            for (var key in schema) {
                switch (key) {
                    // case "nullable":
                    //     //Проверяем на ноль:
                    //     // var isNull = (dataToValidate === null) ? true : false;
                    //     if ((schema["nullable"] == false) &&(dataToValidate === null)) {
                    //         this.Errors.push('Value is null, but nullable false')
                    //     } else {
                    //         //Пишем отчёт, что всё хорошо
                    //         document.write("Null stuff OK" + "<br>");
                    //     }
                    //     break
                    case "type":
                        //Проверяем на ноль:

                        if ((schema["nullable"] == false) &&(dataToValidate === null)) {
                            this.Errors.push('Value is null, but nullable false')
                        } else {
                            //Пишем отчёт, что всё хорошо
                            document.write("Null stuff OK" + "<br>");
                        }

                        //Проверяем, есть ли такой тип в списке:
                        const possTypes = ['number', 'string', 'boolean', 'object', 'array'];
                            if (!(possTypes.includes(schema["type"]))) {
                                this.Errors.push("Unknown type");
                            } else {
                                //Пишем отчёт, что всё хорошо
                                document.write("Type is in the list OK" + "<br>");
                            }

                        //Проверяем, соответствуют ли данные указанному типу (если они не null):
                        const checkTypeOfData = Array.isArray(dataToValidate) ? "array": typeof (dataToValidate)
                        if (!(checkTypeOfData == schema['type']) && !(schema["nullable"])) {
                            this.Errors.push("Type is incorrect");
                            console.log(this.Errors);

                        } else {
                            //Пишем отчёт, что всё хорошо
                            document.write("Type of data matches, OK" + "<br>");
                        }

                        //Начинаем проверять по типам данных:
                        document.write("The type to check further: " + schema["type"] + '<br>');

                        switch (schema["type"]) {
                            case "number" :
                                document.write("It's a number! ->" + schema["type"]+"<br>");
                                document.write("NumberFunction result: "+ this.numberFunction(schema, dataToValidate)+"<br>");
                                break
                            case "string" :
                                document.write("It's a string! ->" +schema["type"]+ "<br>");
                                document.write("StringFunction result: "+ this.stringFunction(schema, dataToValidate)+"<br>");
                                break
                            case "object":
                                document.write("It's an object! ->" +schema["type"]+ "<br>");
                                document.write("ObjectFunction result: "+ this.objectFunction(schema, dataToValidate)+"<br>");
                                break
                            case "array":
                                document.write("It's an array! ->" +schema["type"]+ "<br>");
                                document.write("ArrayFunction result: "+ this.arrayFunction(schema, dataToValidate)+"<br>");
                                break
                        }

                    case "anyOf":
                        // const anyOfValidator01 = new Validator();
                        // console.log("AnyOf: " + schema["anyOf"][0]);
                        // const isValid01 = anyOfValidator01.isValid(schema["anyOf"][0], dataToValidate);
                        // console.log("Case 01: ", isValid01);
                        // const anyOfValidator02 = new Validator();
                        // const isValid02 = anyOfValidator02.isValid(schema["anyOf"][1], dataToValidate);
                        // console.log("Case 02: ", isValid01);

                    case "oneOf":

                }
            }
            const result = (this.Errors.length == 0) ? true : false;
            console.log(this._errors);
            document.write("<br>"+"The result is: " + result);
            return (this.Errors.length == 0) ? true : false;
            // return this.Errors[0];
        }

    }
    validator = new Validator();
    const isValid = validator.isValid({
        type: 'object',
        properties: {
            'a': {
                type: 'string'
            },
            't': {
                type: 'array',
                items: {
                    type: 'number'
                }
            }
        }
    }, {a: 'qwe', t: [1, []]});



    </script>
</head>
<body>
</body>
</html>