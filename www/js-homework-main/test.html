<html>
<head>
    <script>
    class Validator {
        constructor() {
            this._errors = [];
        }

        get Errors() {
            return this._errors;
        }
        /**
         *
         * @param schema
         * @param dataToValidate
         * @returns {boolean}
         */
        numberFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            // var possNumVals = ["minimum", "maximum", "enum"]
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minimum" :
                        document.write("Minimum!<br>");
                        try {
                            if (dataToValidate < schema["minimum"]) {
                                throw new TypeError('Value is less than it can be');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "maximun" :
                        try {
                            if (dataToValidate > schema["maximum"]) {
                                throw new TypeError('Value is greater than it can be');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "enum" :
                        document.write("Enum!<br>");
                        document.write("Enum list: " + schema["enum"]+ '<br>');
                        document.write("Data to validate:" + dataToValidate + '<br>');
                        document.write("Is included: "+ schema["enum"].includes(dataToValidate)+"<br>");

                        try {
                            if (!(schema["enum"].includes(dataToValidate))) {

                                throw new TypeError('The enum does not support value');
                            }
                        } catch (myError) {

                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                }
            }
            // numberFunction.bind(this)();
            console.log(this._errors);
            return (this._errors.length == 0) ? true : false;
        }
        stringFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minLength" :
                        document.write("MinLength!<br>");
                        try {
                            if (dataToValidate.length < schema["minlength"]) {
                                throw new TypeError('Too short string');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "maxLength" :
                        document.write("Maxlength!<br>");
                        try {
                            if (dataToValidate.length > schema["maxlength"]) {
                                throw new TypeError('Too long string');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "pattern" :
                        document.write("Regular!<br>");
                        try {
                            if (dataToValidate.match(schema["pattern"]) == null) {
                                throw new TypeError('String does not match pattern');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "enum" :
                        try {
                            if (!(schema["enum"].includes(dataToValidate))) {

                                throw new TypeError('The enum does not support value');
                            }
                        } catch (myError) {

                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "format" :
                        try {
                            if (((schema["format"] == "email") && (dataToValidate.match(/^[^\s@]+@[^\s@]+$/) == null)) ||
                            ((schema["format"] == "date") && (dataToValidate.match(/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/) == null))){

                                throw new TypeError('Format of string is not valid');
                            }
                        } catch (myError) {

                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                }

                }
            return (this.Errors.length == 0) ? true : false;

        }
        objectFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minProperties" :
                        document.write("MinProperties!<br>");
                        try {
                            if (Object.keys(dataToValidate).length < schema["minproperties"]) {
                                throw new TypeError('Too few properties in object');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "maxProperties" :
                        document.write("Maxproperties!<br>");
                        try {
                            if (Object.keys(dataToValidate).length > schema["maxproperties"]) {
                                throw new TypeError('Too many properties in object');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "required" :
                        document.write("Required!<br>");
                        const setDatatoval = Object.keys(dataToValidate) ;
                        document.write("Keys of Data to validate: " +setDatatoval+ "<br>");
                        document.write("Keys of schema: " +schema["required"]+ "<br>");
                        try {
                            if (Object.keys(dataToValidate).includes(schema["required"]) == false) {
                                // const ifAllOk = Object.keys(dataToValidate).includes(schema["required"]);
                                // document.write("if all ok: " +ifAllOk+ "<br>");
                                throw new TypeError('Property required, but value is undefined');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "properties" :
                        document.write("Properties!!<br>");
                        for (var elem in schema["properties"]) {
                            document.write("Current elem is: " + elem +"<br>")
                            document.write("What to put in new Validator: "+ "<br>");
                            document.write("Instead of schema: schema[\"properties\"].elem"+ ' ' +schema["properties"][elem]+"<br>");
                            document.write("<br>" + "Current schema: " + "<br>");
                            for (var key in schema["properties"][elem]) { //обращаемся к индексам
                                document.write(key, ' ', schema["properties"][elem][key], '<br>')
                            }
                            document.write("<br>")
                            document.write("Instead of data: dataToValidate[elem]"+ ' ' + dataToValidate[elem]+"<br>");
                            console.log(dataToValidate[elem]);
                            const propValidator = new Validator();
                            //дописать после arrays:
                            const addIsValid = propValidator.isValid(schema["properties"][elem], dataToValidate[elem]);
                            document.write("Prop check result: " + addIsValid + "<br><br>");
                            // try {
                            //     if (!(schema["enum"].includes(dataToValidate))) {
                            //
                            //         throw new TypeError('The enum does not support value');
                            //     }
                            // } catch (myError) {
                            //
                            //     console.log(myError);
                            //     this.Errors.push(myError);
                            // }
                        }
                            break
                    case "additionalProperties" :
                        document.write("Add prop!<br>");
                        if (schema["additionalProperties"] == false) {
                            try {
                                const poolKeys = Object.keys(schema["properties"]);
                                const dataKeys = Object.keys(dataToValidate);
                                const diff = dataKeys.filter(x => !poolKeys.includes(x));
                                console.log(diff);
                                if (diff.length > 0) throw new TypeError('An object cant have additional properties');
                            } catch (myError) {
                                console.log(myError);
                                this.Errors.push(myError);
                            }
                        }
                        break
                }
            }
            console.log("Finished Object Func")
            console.log(this._errors)
            return (this.Errors.length == 0) ? true : false;

        }
        arrayFunction (schema = {}, dataToValidate) {
            document.write("Data to validate: "+dataToValidate+"<br>");
            for (var key in schema) { //обращаемся к индексам
                document.write("Current schema is: " + key + " " + schema[key] + "<br>")
                // document.write(+ schema +"<br>");
                switch (key) {
                    case "minItems" :
                        document.write("MinItems!<br>");
                        try {
                            if (dataToValidate.length < schema["minitems"]) {
                                throw new TypeError('Items count less than can be');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "maxItems" :
                        document.write("MaxItesm!<br>");
                        try {
                            if (dataToValidate.length > schema["maxitems"]) {
                                throw new TypeError('Items count more than can be');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "items" :
                        document.write("Items!<br>");
                        // const mya = Object.keys(schema['items']);
                        // console.log(mya, " ", mya.length);
                        if (Object.keys(schema['items']).length > 1)
                    {
                        const posItemTypes = []
                        for (var elem in schema["items"]) {
                            document.write("Element: " + elem + "<br>");
                            document.write("Contents: " + schema["items"].elem + "<br>");
                            posItemTypes.push(schema["items"][elem]["type"]);
                            console.log("Type: " + posItemTypes);
                        }
                        try {
                            for (var elem in dataToValidate) {
                                if (!(posItemTypes.includes(typeof dataToValidate[elem]))) {
                                    throw new TypeError('Type is incorrect');
                                }
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                    } else {
                            try {
                                for (var elem in dataToValidate) {
                                    if ((typeof dataToValidate[elem]) != schema["items"]["type"]) {
                                        throw new TypeError('Type is incorrect');
                                    }
                                }
                            } catch (myError) {
                                console.log(myError);
                                this.Errors.push(myError);
                            }
                        }
                        break
                    case "enum" :
                        document.write("Enum!<br>");

                        try {
                            if (!(schema["enum"].includes(dataToValidate))) {
                                throw new TypeError('The enum does not support one of array elements');
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "contains" :
                        try {
                            if (!(dataToValidate.includes(schema["enum"]))) {

                                throw new TypeError('Must contain a value, but does not');
                            }
                        } catch (myError) {

                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "uniqueItems" :
                        document.write("Case Unique!" + "<br>");
                        try {
                            const tryJSON = dataToValidate.map((object) => JSON.stringify(object));
                            const uSet = new Set(tryJSON);
                            const uniqueElems = Array.from(uSet);
                            const uObjByCont = uniqueElems.map((string) => JSON.parse(string));

                            console.log("uniqueElems: " + uniqueElems);
                            document.write("Length: " + uniqueElems.length + "<br>");
                            if (uniqueElems.length< dataToValidate.length) {
                                throw new TypeError('Elements of array not unique');
                            }
                        } catch (myError) {

                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break                }

            }
            return (this.Errors.length == 0) ? true : false;

        }
        isValid(schema = {}, dataToValidate) {
            for (var key in schema) {
                switch (key) {
                    case "nullable":
                        //Проверяем на ноль:
                        try {
                            // var isNull = (dataToValidate === null) ? true : false;
                            if ((schema["nullable"] == false) &&(dataToValidate === null)) {
                                throw new TypeError('Value is null, but nullable false');
                            } else {
                                //Пишем отчёт, что всё хорошо
                                document.write("Null stuff OK" + "<br>");
                            }
                        } catch (myError){
                            console.log(myError);
                            this.Errors.push(myError);
                        }
                        break
                    case "type":
                        //Проверяем, есть ли такой тип в списке:
                        const possTypes = ['number', 'string', 'boolean', 'object', 'array'];
                        try {
                            if (!(possTypes.includes(schema["type"]))) {
                                throw new TypeError('Unknown type');
                            } else {
                                //Пишем отчёт, что всё хорошо
                                document.write("Type is in the list OK" + "<br>");
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                            console.log(this.Errors);
                            document.write("Unknown type");
                            break
                        }
                        //Проверяем, соответствуют ли данные указанному типу (если они не null):
                        try {
                            // var checkTypeOfData1 = typeof (dataToValidate);
                            // document.write("Type of Data is: " +checkTypeOfData1+ "<br>");
                            // if (checkTypeOfData1 == "object") {
                            //     const isItAnArrray = Array.isArray(dataToValidate);
                            //     document.write("Is it an Array? " +isItAnArrray + "<br>")
                            // }
                            // if (isItAnArrray == true) checkTypeOfData1 = "array";
                            //
                            const checkTypeOfData = Array.isArray(dataToValidate) ? "array": typeof (dataToValidate)
                            if (!(checkTypeOfData == schema['type'])) {
                                throw new TypeError('Type is incorrect');
                            } else {
                                //Пишем отчёт, что всё хорошо
                                document.write("Type of data matches, OK" + "<br>");
                            }
                        } catch (myError) {
                            console.log(myError);
                            this.Errors.push(myError);
                            console.log(this.Errors);
                            document.write("Type is incorrect");
                            break
                        }
                        //Начинаем проверять по типам данных:
                        document.write("The type to check further: " +schema["type"]+ '<br>');

                        switch (schema["type"]) {
                            case "number" :
                                document.write("It's a number! ->" + schema["type"]+"<br>");
                                document.write("NumberFunction result: "+ this.numberFunction(schema, dataToValidate)+"<br>");
                                break
                            case "string" :
                                document.write("It's a string! ->" +schema["type"]+ "<br>");
                                document.write("StringFunction result: "+ this.stringFunction(schema, dataToValidate)+"<br>");
                                break
                            case "object":
                                document.write("It's an object! ->" +schema["type"]+ "<br>");
                                document.write("ObjectFunction result: "+ this.objectFunction(schema, dataToValidate)+"<br>");
                                break
                            case "array":
                                document.write("It's an array! ->" +schema["type"]+ "<br>");
                                document.write("ArrayFunction result: "+ this.arrayFunction(schema, dataToValidate)+"<br>");
                                break
                        }

                    case "anyOf":
                        const anyOfValidator01 = new Validator();
                        console.log("AnyOf: " + schema["anyOf"][0]);
                        const isValid01 = anyOfValidator01.isValid(schema["anyOf"][0], dataToValidate);
                        console.log("Case 01: ", isValid01);
                        // const anyOfValidator02 = new Validator();
                        // const isValid02 = anyOfValidator02.isValid(schema["anyOf"][1], dataToValidate);
                        // console.log("Case 02: ", isValid01);

                    case "oneOf":

                }
            }
            const result = (this.Errors.length == 0) ? true : false;
            document.write("<br>"+"The result is: " + result);
            return (this.Errors.length == 0) ? true : false;
            return this.Errors[0];
        }

    }
    validator = new Validator();
    const isValid = validator.isValid({
        anyOf: [
            {
                type: 'number'
            },
            {
                type: 'string'
            }
        ]
    }, '654');

    </script>
</head>
<body>
</body>
</html>